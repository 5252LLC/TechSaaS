"""
Pentesting Tool Routes

This module provides routes for security testing tools, including
port scanning, DNS enumeration, and vulnerability scanning for
authorized networks only.
"""

import re
import socket
import ipaddress
import dns.resolver
import logging
import threading
import queue
import time
from concurrent.futures import ThreadPoolExecutor
from flask import render_template, request, jsonify, flash, redirect, url_for, current_app
from flask_login import login_required, current_user

from app.routes.pentest import pentest_bp
from app.utils.rate_limiter import rate_limit
from app.utils.decorators import admin_required
from app.utils.network import is_authorized_target

# Configure logging
logger = logging.getLogger(__name__)

@pentest_bp.route('/', methods=['GET'])
@login_required
def index():
    """Pentesting tools dashboard landing page."""
    return render_template('pentest/index.html')

@pentest_bp.route('/port-scan', methods=['GET', 'POST'])
@login_required
@rate_limit(limit=3, period=300)  # Limit to 3 scans per 5 minutes
def port_scan():
    """Basic port scanning functionality."""
    results = None
    target = None
    ports = None
    error = None
    scan_time = None
    
    if request.method == 'POST':
        target = request.form.get('target', '')
        port_range = request.form.get('port_range', '1-1000')
        
        # Validate target
        if not target:
            error = "Target IP or hostname is required"
        elif not is_authorized_target(target):
            error = "Unauthorized target. Only scan authorized networks and domains for testing purposes."
            logger.warning(f"Unauthorized scan attempt by {current_user.username} on {target}")
        else:
            try:
                # Parse port range
                if '-' in port_range:
                    start, end = map(int, port_range.split('-'))
                    ports = range(max(1, start), min(65535, end + 1))
                else:
                    ports = [int(port_range)]
                
                # Resolve hostname if needed
                try:
                    ip = socket.gethostbyname(target)
                except socket.gaierror:
                    error = f"Could not resolve hostname: {target}"
                    return render_template('pentest/port_scan.html', error=error)
                
                start_time = time.time()
                
                # Use threading for faster scanning
                results = []
                result_lock = threading.Lock()
                
                def scan_port(port):
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1.0)  # Slightly longer timeout for better results
                    
                    try:
                        result = sock.connect_ex((ip, port))
                        if result == 0:
                            # Try to identify service
                            service = "Unknown"
                            try:
                                service = socket.getservbyport(port)
                            except (socket.error, OSError):
                                # Check against common ports if getservbyport fails
                                common_ports = {
                                    21: "FTP",
                                    22: "SSH",
                                    23: "Telnet",
                                    25: "SMTP",
                                    53: "DNS",
                                    80: "HTTP",
                                    110: "POP3",
                                    143: "IMAP",
                                    443: "HTTPS",
                                    3306: "MySQL",
                                    3389: "RDP",
                                    5432: "PostgreSQL",
                                    8080: "HTTP-ALT"
                                }
                                service = common_ports.get(port, "Unknown")
                                
                            with result_lock:
                                results.append({
                                    'port': port,
                                    'status': 'Open',
                                    'service': service
                                })
                    except (socket.timeout, ConnectionRefusedError):
                        # Expected exceptions during scanning
                        pass
                    except Exception as e:
                        logger.error(f"Error scanning port {port}: {str(e)}")
                    finally:
                        sock.close()
                
                # Use ThreadPoolExecutor for controlled parallelism
                max_threads = min(50, len(ports))  # Limit max threads
                with ThreadPoolExecutor(max_workers=max_threads) as executor:
                    executor.map(scan_port, ports)
                
                # Sort results by port number
                results.sort(key=lambda x: x['port'])
                
                scan_time = round(time.time() - start_time, 2)
                logger.info(f"Port scan completed by {current_user.username} on {target} in {scan_time}s, found {len(results)} open ports")
                
                # If no ports found, add a message
                if not results:
                    flash(f"No open ports found in the specified range. Scan completed in {scan_time} seconds.", "info")
                
            except ValueError as e:
                error = f"Invalid port range: {str(e)}"
                logger.error(f"Invalid port range: {str(e)}")
            except Exception as e:
                error = f"Error during scan: {str(e)}"
                logger.error(f"Scan error: {str(e)}")
    
    return render_template('pentest/port_scan.html', results=results, target=target, error=error, scan_time=scan_time)

@pentest_bp.route('/dns-lookup', methods=['GET', 'POST'])
@login_required
@rate_limit(limit=5, period=60)
def dns_lookup():
    """DNS lookup and enumeration tool."""
    results = None
    domain = None
    record_type = None
    error = None
    
    if request.method == 'POST':
        domain = request.form.get('domain', '')
        record_type = request.form.get('record_type', 'A')
        
        # Validate domain
        if not domain:
            error = "Domain name is required"
        elif not is_authorized_target(domain):
            error = "Unauthorized target. Only lookup authorized domains."
            logger.warning(f"Unauthorized DNS lookup attempt by {current_user.username} on {domain}")
        else:
            try:
                resolver = dns.resolver.Resolver()
                resolver.timeout = 3
                resolver.lifetime = 3
                
                answers = resolver.resolve(domain, record_type)
                results = [{'record': record_type, 'value': str(rdata)} for rdata in answers]
                
                logger.info(f"DNS lookup completed by {current_user.username} for {domain} ({record_type})")
                
            except dns.exception.DNSException as e:
                error = f"DNS lookup error: {str(e)}"
                logger.error(f"DNS lookup error: {str(e)}")
    
    return render_template('pentest/dns_lookup.html', results=results, domain=domain, error=error)

@pentest_bp.route('/whois', methods=['GET', 'POST'])
@login_required
@rate_limit(limit=5, period=60)
def whois_lookup():
    """WHOIS information lookup."""
    results = None
    domain = None
    error = None
    
    if request.method == 'POST':
        domain = request.form.get('domain', '')
        
        # Validate domain
        if not domain:
            error = "Domain name is required"
        elif not is_authorized_target(domain):
            error = "Unauthorized target. Only lookup authorized domains."
            logger.warning(f"Unauthorized WHOIS lookup attempt by {current_user.username} on {domain}")
        else:
            # Mock WHOIS data for demo purposes
            # In production, this would call the python-whois library
            results = {
                'domain_name': domain,
                'registrar': 'Example Registrar, LLC',
                'whois_server': 'whois.example-registrar.com',
                'creation_date': '2020-01-01',
                'expiration_date': '2025-01-01',
                'name_servers': ['ns1.example.com', 'ns2.example.com'],
                'status': ['clientTransferProhibited'],
                'emails': ['admin@example.com']
            }
            
            logger.info(f"WHOIS lookup completed by {current_user.username} for {domain}")
    
    return render_template('pentest/whois.html', results=results, domain=domain, error=error)

@pentest_bp.route('/headers', methods=['GET', 'POST'])
@login_required
@rate_limit(limit=10, period=60)
def http_headers():
    """HTTP headers analysis tool."""
    results = None
    url = None
    error = None
    
    if request.method == 'POST':
        url = request.form.get('url', '')
        
        # Validate URL
        if not url:
            error = "URL is required"
        elif not url.startswith(('http://', 'https://')):
            url = 'https://' + url
            
        if not error:
            if not is_authorized_target(url):
                error = "Unauthorized target. Only scan authorized websites."
                logger.warning(f"Unauthorized header scan attempt by {current_user.username} on {url}")
            else:
                try:
                    import requests
                    resp = requests.head(url, timeout=5)
                    results = dict(resp.headers)
                    
                    # Security header analysis
                    security_headers = {
                        'Strict-Transport-Security': 'missing',
                        'Content-Security-Policy': 'missing',
                        'X-Content-Type-Options': 'missing',
                        'X-Frame-Options': 'missing',
                        'X-XSS-Protection': 'missing',
                        'Referrer-Policy': 'missing'
                    }
                    
                    for header in security_headers.keys():
                        if header in results:
                            security_headers[header] = 'present'
                    
                    logger.info(f"HTTP headers scan completed by {current_user.username} for {url}")
                    
                except Exception as e:
                    error = f"Error fetching headers: {str(e)}"
                    logger.error(f"Headers scan error: {str(e)}")
    
    return render_template('pentest/http_headers.html', results=results, security_headers=security_headers if 'security_headers' in locals() else None, url=url, error=error)
